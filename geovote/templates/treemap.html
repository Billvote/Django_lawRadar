{% extends "base.html" %}

{% block body %}
<div class="flex h-[700px]">
  <!-- 사이드바 -->
  <aside class="w-48 bg-gray-100 p-4 overflow-y-auto border-r border-gray-300">
    <h2 class="font-bold text-lg mb-4">대수 선택</h2>
    <ul id="ageList" class="space-y-2">
      {% for age in ages %}
      <li>
        <button
          class="age-btn w-full text-left px-3 py-2 rounded hover:bg-indigo-500 hover:text-white transition"
          data-age="{{ age.id }}">
          {{ age.number }} 대
        </button>
      </li>
      {% endfor %}
    </ul>
  </aside>

  <!-- 메인 트리맵 컨테이너 -->
  <main class="flex-1 p-4 relative flex flex-col">
    <h2 class="text-3xl font-bold text-center text-slate-800 mb-6">지역구 의원 트리맵</h2>
    <div class="text-center mb-4">
      <button id="backButton" class="hidden bg-indigo-600 text-white px-4 py-2 rounded-lg shadow hover:bg-indigo-700 transition">뒤로가기</button>
    </div>
    <div id="treemap" class="flex-1 bg-white rounded-xl shadow"></div>
  </main>
</div>
{% endblock %}

{% block script %}
<script src="https://d3js.org/d3.v6.min.js"></script>
<script>
  const container = document.getElementById("treemap");
  const backButton = d3.select("#backButton");
  let svg, treemapLayout, currentNode, hierarchyRoot;

  function getFontSize(width, height, text) {
    const padding = 10;
    const estimated = Math.min(
      (width - padding) / (text.length * 0.6),
      (height - padding) / 1.2
    );
    return isNaN(estimated) || estimated <= 0 ? 12 : Math.max(10, Math.min(estimated, 20));
  }

  function render(node, width, height) {
    d3.select("#treemap svg").remove();
    svg = d3.select("#treemap").append("svg")
      .attr("width", width)
      .attr("height", height);

    backButton.classed("hidden", !node.parent);

    const group = svg.append("g");
    const xScale = d3.scaleLinear().domain([node.x0, node.x1]).range([0, width]);
    const yScale = d3.scaleLinear().domain([node.y0, node.y1]).range([0, height]);

    // 계층별로 보여줄 children 분기
    let childrenToShow = node.children || [];
    if (node.depth === 0) {
      // root: SIDO만 보여줌
      childrenToShow = (node.children || []).filter(d => d.children && d.children.length > 0);
    } else if (node.depth === 1) {
      // SIDO: SIGUNGU만 보여줌 (의원정보X)
      childrenToShow = (node.children || []).filter(d => d.children && d.children.length > 0);
    } else if (node.depth === 2) {
      // SIGUNGU: 의원정보(leaf)만 보여줌
      childrenToShow = (node.children || []).filter(d => !d.children || d.children.length === 0);
    }

    const nodes = group.selectAll("g")
      .data(childrenToShow)
      .join("g")
      .attr("class", "node")
      .attr("transform", d => `translate(${xScale(d.x0)},${yScale(d.y0)})`)
      .style("cursor", d => d.children && d.children.length > 0 ? "pointer" : "default")
      .on("click", (event, d) => {
        if (d.children && d.children.length > 0) {
          currentNode = d;
          render(d, width, height);
        }
      });

    nodes.append("rect")
      .attr("width", d => xScale(d.x1) - xScale(d.x0))
      .attr("height", d => yScale(d.y1) - yScale(d.y0))
      .attr("fill", d => {
        if (!d.children && d.data.color) return d.data.color;
        return "#e0e0e0";
      });

    nodes.append("text")
      .attr("x", d => (xScale(d.x1) - xScale(d.x0)) / 2)
      .attr("y", d => (yScale(d.y1) - yScale(d.y0)) / 2)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .style("font-size", d => {
        const w = xScale(d.x1) - xScale(d.x0);
        const h = yScale(d.y1) - yScale(d.y0);
        return getFontSize(w, h, d.data.name) + "px";
      })
      .style("fill", "#ffffff")
      .style("font-weight", "600")
      .style("pointer-events", "none")
      .text(d => d.data.name);
  }

  function resize() {
    const width = container.clientWidth;
    const height = container.clientHeight;

    d3.select("#treemap svg").remove();
    svg = d3.select("#treemap").append("svg")
      .attr("width", width)
      .attr("height", height);

    treemapLayout.size([width, height]);

    if (!hierarchyRoot) return;

    render(currentNode, width, height);
  }

  async function loadData(age) {
    const response = await fetch(`/api/region-tree/?age=${age}`);
    if (!response.ok) {
      console.error("데이터 로드 실패");
      return null;
    }
    return await response.json();
  }

  async function init(age) {
    const data = await loadData(age);
    if (!data) return;

    // value를 모두 1로 고정해 모든 계층에서 격자 크기 동일하게
    hierarchyRoot = d3.hierarchy(data)
      .sum(d => 1)
      .sort((a, b) => b.value - a.value);

    treemapLayout = d3.treemap()
      .size([container.clientWidth, container.clientHeight])
      .paddingInner(2);

    treemapLayout(hierarchyRoot);

    currentNode = hierarchyRoot;

    d3.select("#treemap svg").remove();
    svg = d3.select("#treemap").append("svg")
      .attr("width", container.clientWidth)
      .attr("height", container.clientHeight);

    render(currentNode, container.clientWidth, container.clientHeight);
  }

  document.querySelectorAll(".age-btn").forEach(button => {
    button.addEventListener("click", async () => {
      const age = button.getAttribute("data-age");
      await init(age);
      document.querySelectorAll(".age-btn").forEach(btn => btn.classList.remove("bg-indigo-600", "text-white"));
      button.classList.add("bg-indigo-600", "text-white");
    });
  });

  backButton.on("click", () => {
    if (currentNode.parent) {
      currentNode = currentNode.parent;
      const width = container.clientWidth;
      const height = container.clientHeight;
      render(currentNode, width, height);
    }
  });

  window.addEventListener("DOMContentLoaded", () => {
    const firstBtn = document.querySelector(".age-btn");
    if (firstBtn) {
      firstBtn.click();
    }
  });

  window.addEventListener("resize", resize);
</script>
{% endblock %}
